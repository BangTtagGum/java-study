배열

입력, 변경, 조회의 경우 인덱스를 통해 O(1)의 시간복잡도로 처리 가능하다.
->  배열을 할당하면 heap 영역에 메모리가 할당되고, 배열은 메모리상에 연결되어 할당되기 때문에 인덱스에 따라
    한번의 계산으로 해당 메모리 위치에 바로 접근할 수 있다. 
    -> 배열의 시작 참조 + (자료의 크기 * 인덱스 위치)

검색의 경우 데이터를 하나하나 조회하기에 O(n)의 시간복잡도로 처리 가능하다.
->  컴퓨터는 사람과 달라서 한눈에 데이터의 위치를 찾아낼 수 없어서 배열의 시작부터 데이터를 찾을 때 까지 하나하나 조회해야한다.

빅오(O) 표기법
->  빅오 표기법은 알고리즘의 성능을 분석할 때 사용하는 수학적 표현 방식이다. 또한 빅오 표기법은 정확한 실행시간을 계산하는것이 아니고,
    대략적인 소요 시간을 나타내는데 사용된다.

빅오 표기법의 예시
-> O(1) - 데이터의 양과 상관없이 알고리즘의 실행 시간이 일정하다.
    ->  ex) 배열에서 인덱스를 사용하는 경우
-> O(n) - 선형시간 : 알고리즘의 실행시간이 입력 데이터의 크기에 비례해서 증가한다.
    ->  ex) 배열의 검색, 배열의 모든 요소를 순회하는 경우
-> O(n^2) - 제곱 시간: 알고리즘의 실행 시간이 입력 데이터의 크기의 제곱에 비례하여 증가한다.
    ->  ex) 이중 for문을 사용하는 알고리즘
-> O(log n) - 로그 시간: 알고리즘의 실행 시간이 데이터 크기의 로그에 비례하여 증가한다.
    ->  ex) 이진 탐색
-> O(n log n) - 선형 로그 시간:
    -> 예) 많은 효율적인 정렬 알고리즘들

->  빅오 표기법은 매우 큰 데이터를 입력한다고 가정하고, 정확한 성능을 측정하는 것이 아니어서 상수를 제거한다.
->  빅오 표기법은 별도의 이야기가 없으면 보통 최악의 상황을 가정해서 표기한다.

배열의 한계
->  배열은 가장 기본적인 자료구조이고, 인덱스를 사용할 때 최고의 효율을 보인다. 그러나 배열을 생성하는 시점에 배열의 크기를 미리 정해야
    한다는 단점이 존재한다. 적당히 할당했다 생각했는데 나중에 배열의 크기가 모자랄 수 있고, 그렇다고 너무 큰 배열을 할당받기에는 메모리
    부담이 크게 된다.
    ->  이러한 단점을 완화시키기 위한 자료구조가 List 다.

리스트
->  배열의 경우 불편한 점
    ->  배열의 길이를 동적으로 변경 불가능하다.
    ->  데이터를 추가하기 불편하다.

배열의 이런 불편함을 해소하고 동적으로 데이터를 추가할 수 있는 자료구조 List
->   배열과 동일한 역할을 하지만, 크기가 동적으로 변한다.


MyArrayList에 제네릭을 적용했을 때 new E[] 로 제네릭 배열 생성이 불가능한 이유
```java
public class MyArrayListV4<E> {

    private static final int DEFAULT_CAPACITY = 5;

    private Object[] elementData;
    // private E[] elementData; // 불가능
    private int size = 0;

    public MyArrayListV4() {
        elementData = new Object[DEFAULT_CAPACITY];
    }

    public MyArrayListV4(int initialCapacity) {
        elementData = new Object[initialCapacity];
    }
    /**
     * ... 
     */
}
```
->  제네릭은 런타임에 이레이저에 의해 타입정보가 사라진다. 따라서 런타임에 타입 정보가 필요한 생성자에 사용할 수 없다.
    -> 따라서 모든 데이터를 담을 수 있는 Object배열을 그대로 사용한다.

ArrayList의 빅오 정리
->  데이터 추가
    ->  마지막 추가 :O(1)
    ->  앞, 중간 추가 :O(n)
->  데이터 삭제
    ->  마지막 추가 :O(1)
    ->  앞, 중간 추가 :O(n)
->  인덱스 조회 :O(1)
->  데이터 검색 :O(n)