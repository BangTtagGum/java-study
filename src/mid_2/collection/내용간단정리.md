배열

입력, 변경, 조회의 경우 인덱스를 통해 O(1)의 시간복잡도로 처리 가능하다.
->  배열을 할당하면 heap 영역에 메모리가 할당되고, 배열은 메모리상에 연결되어 할당되기 때문에 인덱스에 따라
    한번의 계산으로 해당 메모리 위치에 바로 접근할 수 있다. 
    -> 배열의 시작 참조 + (자료의 크기 * 인덱스 위치)

검색의 경우 데이터를 하나하나 조회하기에 O(n)의 시간복잡도로 처리 가능하다.
->  컴퓨터는 사람과 달라서 한눈에 데이터의 위치를 찾아낼 수 없어서 배열의 시작부터 데이터를 찾을 때 까지 하나하나 조회해야한다.

빅오(O) 표기법
->  빅오 표기법은 알고리즘의 성능을 분석할 때 사용하는 수학적 표현 방식이다. 또한 빅오 표기법은 정확한 실행시간을 계산하는것이 아니고,
    대략적인 소요 시간을 나타내는데 사용된다.

빅오 표기법의 예시
-> O(1) - 데이터의 양과 상관없이 알고리즘의 실행 시간이 일정하다.
    ->  ex) 배열에서 인덱스를 사용하는 경우
-> O(n) - 선형시간 : 알고리즘의 실행시간이 입력 데이터의 크기에 비례해서 증가한다.
    ->  ex) 배열의 검색, 배열의 모든 요소를 순회하는 경우
-> O(n^2) - 제곱 시간: 알고리즘의 실행 시간이 입력 데이터의 크기의 제곱에 비례하여 증가한다.
    ->  ex) 이중 for문을 사용하는 알고리즘
-> O(log n) - 로그 시간: 알고리즘의 실행 시간이 데이터 크기의 로그에 비례하여 증가한다.
    ->  ex) 이진 탐색
-> O(n log n) - 선형 로그 시간:
    -> 예) 많은 효율적인 정렬 알고리즘들

->  빅오 표기법은 매우 큰 데이터를 입력한다고 가정하고, 정확한 성능을 측정하는 것이 아니어서 상수를 제거한다.
->  빅오 표기법은 별도의 이야기가 없으면 보통 최악의 상황을 가정해서 표기한다.

배열의 한계
->  배열은 가장 기본적인 자료구조이고, 인덱스를 사용할 때 최고의 효율을 보인다. 그러나 배열을 생성하는 시점에 배열의 크기를 미리 정해야
    한다는 단점이 존재한다. 적당히 할당했다 생각했는데 나중에 배열의 크기가 모자랄 수 있고, 그렇다고 너무 큰 배열을 할당받기에는 메모리
    부담이 크게 된다.
    ->  이러한 단점을 완화시키기 위한 자료구조가 List 다.

리스트
->  배열의 경우 불편한 점
    ->  배열의 길이를 동적으로 변경 불가능하다.
    ->  데이터를 추가하기 불편하다.

배열의 이런 불편함을 해소하고 동적으로 데이터를 추가할 수 있는 자료구조 List
->   배열과 동일한 역할을 하지만, 크기가 동적으로 변한다.


MyArrayList에 제네릭을 적용했을 때 new E[] 로 제네릭 배열 생성이 불가능한 이유
```java
public class MyArrayListV4<E> {

    private static final int DEFAULT_CAPACITY = 5;

    private Object[] elementData;
    // private E[] elementData; // 불가능
    private int size = 0;

    public MyArrayListV4() {
        elementData = new Object[DEFAULT_CAPACITY];
    }

    public MyArrayListV4(int initialCapacity) {
        elementData = new Object[initialCapacity];
    }
    /**
     * ... 
     */
}
```
->  제네릭은 런타임에 이레이저에 의해 타입정보가 사라진다. 따라서 런타임에 타입 정보가 필요한 생성자에 사용할 수 없다.
    -> 따라서 모든 데이터를 담을 수 있는 Object배열을 그대로 사용한다.

ArrayList의 빅오 정리
->  데이터 추가
    ->  마지막 추가 :O(1)
    ->  앞, 중간 추가 :O(n)
->  데이터 삭제
    ->  마지막 추가 :O(1)
    ->  앞, 중간 추가 :O(n)
->  인덱스 조회 :O(1)
->  데이터 검색 :O(n)

LinkedList의 빅오
->  데이터 추가
    ->  마지막 추가 : O(n) - 데이터 추가 자체는 O(1) 그러나 마지막 노드를 찾는데 O(n)
        ->  자바가 제공하는 연결리스트는 마지막 노드를 참조하는 변수를 가지고있어 뒤에 추가, 삭제의 경우 O(1) 이 걸린다.
    ->  중간에 추가 : O(n)
->  데이터 변경 : O(n)
->  인덱스 조회 :O(n)
->  데이터 검색 :O(n)


ArrayList vs LinkedList

->  ArrayList 는 메모리 낭비가 생길 수 있지만, LinkedList는 메모리의 낭비가 훨씬 적다.
->  데이터를 조회할 일이 많고, 데이터를 뒷부분에 추가한다면 ArrayList가 더 좋은 성능을 보인다.
->  앞쪽에 데이터를 추가하거나 삭제할 일이 많다면 LinkedList를 사용하는것이 더 좋은 성능을 제공한다.

컴파일 타임, 런타임 의존관계
package mid_2.collection.list;

```java
public class BatchProcessor {

    private final MyList<Integer> list;

    public BatchProcessor(MyList<Integer> list) {
        this.list = list;
    }
}
```

컴파일 타임 -> 코드 컴파일 시점
    ->  컴파일 타임 의존관계는 자바 컴파일러가 보는 의존관계이다. 클래스에 모든 의존관계가 다 나타난다.
    ->  쉽게 말하면 클래스에 바로 보이는 의존관계이다. 실행하지 않는 소스코드에 정적으로 나타나는 의존관계이다.
    ->  BatchProcessor는 MyList 인터페이스에 의존 (MyArrayList에 의존하는지 MyLinkedList에 의존하는지는 알 수 없다)

런타임 -> 프로그램 실행 시점
    ->  실제 프로그램이 작동될 때 보이는 의존관계이다. 생성된 인스턴스와 그것을 참조하는 의존관계이다.
    ->  쉽게 말하면 프로그램이 실행될 때 인스턴스 간에 의존관계로 보면 된다.
    ->  런타임 의존관계는 프로그램 실행 중에 계속 변할 수 있다.


```java
MyLinkedList<Integer> list = new MyLinkedList<>();
BatchProcessor processor = new BatchProcessor(list);
```
->  BatchProcessor 인스턴스의 MyList list는 생성자를 통해 MyLinkedList(x002) 인스턴스를 참조한다.
    -> BatchProcessor의 list에 MyLinkedList 의존관계를 주입한다.

```java
MyArrayList<Integer> list = new MyArrayList<>();
BatchProcessor processor = new BatchProcessor(list);
```
->  BatchProcessor 인스턴스의 MyList list는 생성자를 통해 MyArrayList(x002) 인스턴스를 참조한다.
    -> BatchProcessor의 list에 MyArrayList 의존관계를 주입한다.

컴파일 타임에 구체적인 인스턴스를 의존한다면, 추후에 해당 인스턴스를 다른 타입으로 변경하려면 코드를 직접 수행해야한다. 
    ->  그러나 추상화만 의존관계로 가지고, 인스턴스를 런타임에 의존할 수 있도록 주입해준다면 추후에 해당 인스턴스를
        변경하더라도 의존관계 주입만 변경해주면 해결된다.

재사용성을 높이려면 나중으로 미뤄야 한다!


MyArrayList 와 MyLinkedList 검색 속도 차이 10000번 loop
==MyArrayList 검색==
findValue: 0, 반복: 10000, 계산 시간: 1ms
findValue: 25000, 반복: 10000, 계산 시간: 214ms
findValue: 49999, 반복: 10000, 계산 시간: 403ms
==MyLinkedList 검색==
findValue: 0, 반복: 10000, 계산 시간: 1ms
findValue: 25000, 반복: 10000, 계산 시간: 718ms
findValue: 49999, 반복: 10000, 계산 시간: 1685ms

검색에는 똑같이 데이터를 찾을 떄 까지 순회해야하기 때문에 O(n)의 시간이 들어야하는데 왜 성능 차이가 날까?
->  참조 지역성 때문에 차이가 난다. 배열은 메모리가 순차적으로 할당되어 있기 때문에 메모리 접근 속도, CPU의 캐싱 등에 영향을 받는다
    ->  ArrayList는 메모리가 연속적으로 위치하여 캐시 효율이 좋고, 메모리 접근 속도가 빠르다.
    ->  LinkedList는 메모리가 메모리에 퍼져 존재하기 때문에 CPU 캐시 효율이 떨어지고, 메모리 접근 속도가 상대적으로 느리다.
    ->  ArrayList의 경우 CAPACITY를 넘어가면 배열을 1.5배로 늘려 복사하는 더블링이 일어나지만 이 과정은 가끔 발생해서 전체 성능에
        크게 영향을 주지는 않는다.



Java ArrayList
->  기본 CAPACITY는 10
->  로드팩터 1을 넘기면(데이터가 다 차면) 1.5배로 배열을 증가시킨다
    10 -> 15 -> 22-> 33 -> 49으로 증가
->  메모리 고속 복사 연산을 사용한다.
    ->  ArrayList의 중간 위치에 데이터를 추가하면, 추가할 위치 이후의 모든 요소를 한칸씩 뒤로 밀어야한다.
    ->  ArrayList는 이런 부분을 최적화 하는데, 배열의 요소 이동은 시스템 레벨에서 최적화된 고속 복사 연산(System.arraycopy())을 사용해서
        비교적 빠르게 수행된다. (시스템 레벨에서 배열을 한번에 아주 빠르게 복사한다, 대략 n/10 정도로 생각하자) 
        
Java LinkedList
->  이중 연결 리스트 구조
->  첫번째 노드와 마지막 노드 둘다 참조
    ->  마지막 노드도 참조하기에 데이터를 마지막에 추가하더라도 O(1)의 성능을 제공한다.
->  이전 노드로 이동할 수 있기 때문에 마지막 노드부터 앞으로(역방향으로) 조회할 수 있다.
    ->  인덱스 조회 성능을 최적화 할 수 있다.
    ->  인덱스가 사이즈의 절반 이하라면 처음부터 찾아서 올라가고, 인덱스가 사이즈의 절반을 넘으면 마지막 노드부터 역방향으로 조회해서 성능을 최적화 가능하다.

MyArrayList 와 MyLinkedList 검색 속도 차이 10000번 loop
==ArrayList 추가==
앞에 추가 - 크기: 50000, 계산 시간: 169ms -> 고속복사 System.arraycopy()를 사용해서 비교적 빠르다.
평균 추가 - 크기: 50000, 계산 시간: 67ms
뒤에 추가 - 크기: 50000, 계산 시간: 3ms
==LinkedList 추가==
앞에 추가 - 크기: 50000, 계산 시간: 5ms
평균 추가 - 크기: 50000, 계산 시간: 1871ms
뒤에 추가 - 크기: 50000, 계산 시간: 3ms
==ArrayList 조회==
index: 0, 반복: 10000, 계산 시간: 1ms
index: 25000, 반복: 10000, 계산 시간: 0ms
index: 49999, 반복: 10000, 계산 시간: 1ms
==LinkedList 조회==
index: 0, 반복: 10000, 계산 시간: 0ms
index: 25000, 반복: 10000, 계산 시간: 506ms
index: 49999, 반복: 10000, 계산 시간: 0ms       -> 맨 뒤도 참조하기 때문에 빠르다.
==ArrayList 검색==
findValue: 0, 반복: 10000, 계산 시간: 1ms
findValue: 25000, 반복: 10000, 계산 시간: 216ms
findValue: 49999, 반복: 10000, 계산 시간: 363ms
==LinkedList 검색==
findValue: 0, 반복: 10000, 계산 시간: 1ms
findValue: 25000, 반복: 10000, 계산 시간: 633ms
findValue: 49999, 반복: 10000, 계산 시간: 1374ms


대부분의 경우 ArrayList가 성능상 유리하다. 실무에서는 주로 배열 리스트를 기본으로 사용한다.
데이터를 앞쪽에 자주 추가하거나 삭제할 일이 있다면 연결리스트를 고려하자.


리스트 vs 세트
List 리스트
    ->  순서 유지
    ->  중복 허용
    ->  인덱스 접근
->  순서가 중요하거나 중복된 요소를 허용해야 하는 경우 주로 사용

Set 세트
    ->  순서 미보장  
    ->  중복 불가
    ->  빠른 검색
->  중복을 허용하지 않고, 요소의 유무만 중요한 경우에 사용

List: 장바구니 목록, 순서가 중요한 일련의 이벤트 목록
Set: 회원 ID 집합, 고유한 항목의 집합

Set 최적화하기
->  Set을 array로 구현한다면 중복을 체크할 때 모든 데이터를 한번씩 체크하며 중복을 확인해야한다. O(n)
    ->  개선할 방법이 있을까? -> Hash, Tree   

Hash 알고리즘
->  검색 성능을 평균 O(1)로 끌어올릴 수 있다.

검색 방법 
순차 탐색 O(n)
```java
public static void main(String[] args) {
    Integer[] inputArray = new Integer[4];
    inputArray[0] = 1;
    inputArray[1] = 2;
    inputArray[2] = 5;
    inputArray[3] = 8;
    System.out.println("inputArray = " + Arrays.toString(inputArray));

    int searchValue = 8;
    // 4번 반복 O(n)
    for (int inputValue : inputArray) {
        if (inputValue == searchValue) {
            System.out.println(inputValue);
        }
    }
}
```

index 탐색 - O(1)
->  시간은 O(1) 이지만, 공간 복잡도가 O(n) 으로 늘어난다.
->  입력값의 범위가 늘어난다면 사용하기 어렵다.
->  공간도 아끼면서 빠르게 검색할 순 없을까?
```java
public static void main(String[] args) {
    //입력: 1, 2, 5, 8
    //[null, 1, 2, null, null, 5, null, null, 8, null]
    Integer[] inputArray = new Integer[10];
    inputArray[1] = 1;
    inputArray[2] = 2;
    inputArray[5] = 5;
    inputArray[8] = 8;
    System.out.println("inputArray = " + Arrays.toString(inputArray));

    int searchValue = 8;
    Integer result = inputArray[searchValue]; // O(1)
    System.out.println(result);
}
```

나머지 연산 O(1)
->  hashIndex()로 인덱스를 구하고, 저장, 검색 한다.
->  1,11 두값은 해시인덱스가 1 로 충돌이 발생할 수 있다.
```java
static void add(Integer[] inputArray, int value) {
    int hashIndex = hashIndex(value);
    inputArray[hashIndex] = value;
}

static int hashIndex(int value) {
    return value % CAPACITY;
}
```

해시 충돌 해결
->  해시 충돌이 낮은 확률로 일어날 것으로 가정하고, 같은 인덱스의 값을 함께 저장해서 해결할 수 있다.
    ->  ex) int[] 대신 Linkedlist[] 를 사용
    ->  9, 99 가 저장되었을 때 인덱스 9로 가서 해당 리스트에서 값을 조회한다.
